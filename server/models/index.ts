import * as path from 'path';
import {
    DataSource,
    DataSourceOptions,
    EntityTarget,
    EntityManager,
    Repository,
    ObjectLiteral,
} from 'typeorm';

import { assert, panic, makeLogger } from '../helpers';

import Access from './entities/accesses';
import AccessField from './entities/access-fields';
import Account from './entities/accounts';
import Alert from './entities/alerts';
import Budget from './entities/budgets';
import Category from './entities/categories';
import Setting from './entities/settings';
import Transaction from './entities/transactions';
import TransactionRule from './entities/transaction-rule';
import TransactionRuleAction from './entities/transaction-rule-action';
import TransactionRuleCondition from './entities/transaction-rule-condition';
import User from './entities/users';
import RecurringTransaction from './entities/recurring-transactions';
import AppliedRecurringTransaction from './entities/applied-recurring-transactions';
import View from './entities/views';

export {
    Access,
    AccessField,
    Account,
    Alert,
    Budget,
    Category,
    Setting,
    Transaction,
    TransactionRule,
    TransactionRuleAction,
    TransactionRuleCondition,
    User,
    RecurringTransaction,
    AppliedRecurringTransaction,
    View,
};

const log = makeLogger('models/index');
let dataSource: DataSource | null;

function makeOrmConfig(): DataSourceOptions {
    let ormConfig: DataSourceOptions;

    // Keep this switch in sync with ../config.ts!
    switch (process.kresus.dbType) {
        case 'sqlite':
            assert(process.kresus.sqlitePath !== null, 'missing db path in server/models');
            ormConfig = {
                type: 'sqlite',
                database: process.kresus.sqlitePath,
                logging: process.kresus.dbLog,
            };
            break;

        case 'postgres':
        case 'mysql':
        case 'mariadb':
            assert(typeof process.kresus.dbHost === 'string', 'missing db host in server/models');
            assert(typeof process.kresus.dbPort === 'number', 'missing db port in server/models');
            assert(
                typeof process.kresus.dbUsername === 'string',
                'missing db username in server/models'
            );
            assert(
                typeof process.kresus.dbPassword === 'string',
                'missing db password in server/models'
            );
            assert(typeof process.kresus.dbName === 'string', 'missing db name in server/models');
            ormConfig = {
                type: process.kresus.dbType,
                host: process.kresus.dbHost,
                port: process.kresus.dbPort,
                username: process.kresus.dbUsername,
                password: process.kresus.dbPassword,
                database: process.kresus.dbName,
                logging: process.kresus.dbLog,
            };
            break;
        default:
            panic('unexpected db type in server/models');
    }

    return ormConfig;
}

export async function setupOrm(): Promise<DataSource> {
    const ormConfig = Object.assign(makeOrmConfig(), {
        // Automatically run migrations.
        migrationsRun: true,

        // Entity models.
        entities: [path.join(__dirname, 'entities/*')],

        // Subscribers.
        subscribers: [path.join(__dirname, 'subscribers/*')],

        // Migration files.
        migrations: [path.join(__dirname, 'migrations/*')],

        // Use one transaction by migration, avoiding issues on promises hanging after alter table.
        migrationsTransactionMode: 'each',

        // Automatically synchronize the database schema on startup. Very
        // unsafe, use only to look at queries generated by the ORM.
        synchronize: false,
    });

    dataSource = new DataSource(ormConfig);
    await dataSource.initialize();
    log.info('database is ready');
    return dataSource;
}

export function getRepository<T extends ObjectLiteral>(x: EntityTarget<T>): Repository<T> {
    if (dataSource === null || typeof dataSource === 'undefined') {
        panic('Expected data source to be initialized');
    }
    return dataSource.getRepository(x);
}

export function getManager(): EntityManager {
    if (dataSource === null || typeof dataSource === 'undefined') {
        panic('Expected data source to be initialized');
    }
    return dataSource.manager;
}

export async function initModels() {
    dataSource = await setupOrm();

    let userId;
    if (process.kresus.providedUserId !== null) {
        userId = process.kresus.providedUserId;
        // Check that the user actually exists already.
        const user = await User.find(userId);
        if (!user) {
            throw new Error(
                `The user with provided ID ${userId} doesn't exist. Did you run "kresus create:user" first?`
            );
        }
    } else {
        // Create default user.
        let user: User | null;
        const users: User[] = await User.all();
        if (!users.length) {
            const { login } = process.kresus.user;
            assert(!!login, 'There should be a default login set!');
            log.info('Creating default user...');
            user = await User.create({ login });
        } else if (users.length > 1) {
            throw new Error(
                'Several users in database but no user ID provided. Please provide a user ID'
            );
        } else {
            user = users[0];
        }
        userId = user.id;
    }

    process.kresus.user.id = userId;
    log.info(`User has id ${userId}`);
}
